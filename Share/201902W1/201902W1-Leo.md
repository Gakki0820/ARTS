# RabbitMQ3 - Publish/Subscribe

为了保持专注做一件事情并尽快做完，于是最近把除算法以外的三个指标都写成 RabbitMQ 相关的，否则一周翻译学习一篇太慢了，学个 RabbitMQ 不知道要学到啥时候。

注：本文为翻译

**原文地址：https://www.rabbitmq.com/tutorials/tutorial-three-java.html**



## 发布 / 订阅

在前一章中，我们创建了工作队列。工作队列背后的假设是，每个任务只交付给一个工作者。在这一部分中，我们将做一些完全不同的事情：我们将向多个消费者传递消息，这种模式称为「发布 / 订阅」

为了演示该模式，我们将构建一个简单的日志系统，它将由两个程序组成：第一个程序将发出日志消息，第二个程序将接受并打印它们。

在我们的日志系统中，接收程序的每个运行副本都将获得消息。这样我们就可以运行一个接收器并将日志定向到磁盘，同时，我们可以运行另一个接收器在屏幕上看到日志。

实际上，发布的日志消息将广播给所有接收方。



## 交换器

在前一几章，我们向队列发送和接收消息。现在是时候在 Rabbit 中引入完整的消息模型了。

让我们快速回顾一下我们在之前的章节中介绍的内容：

- 生产者是发送消息的用户应用程序
- 队列是存储消息的缓冲区
- 消费者是接收消息的用户应用程序

RabbitMQ 中消息模型的核心思想是：生产者从不直接向队列发送任何消息。实际上，生产者通常根本不知道消息是否会被传递到任何队列。

相反，生产者只能向交换器发送消息。交换是一件很简单的事情。一方面，它接收来自生产者的消息，另一个方面，它将消息推送到队列中，交换器必须明确地知道如何处理它接受到的消息。是否应该将其附加到特定队列中？它应该添加到许多队列中吗？或者它应该被丢弃。这些规则都由交换类型来定义。

![img](https://www.rabbitmq.com/img/tutorials/exchanges.png)

有几种可用的交换类型：direct、topic、headers 和 fanout。我们将关注最后一个 fanout。让我们创建这种类型的交换，并将其称为 logs：

```java
channel.exchangeDeclare("logs", "fanout");
```

fanout 交换器非常简单，正如您可能从名称猜到，它只是将接收到的所有消息广播到它知道的所有队列。这正是我们的日志记录器所需要的。



**列出交换器**

要列出服务器上的交换器，可以使用非常有用的 rabbitmqctl 工具：

```shell
sudo rabbitmqctl list_exchanges
```

在这个列表中会有一些 amq.* 交换器和默认（未命名）的交换器，这些都是默认创建的，但是您现在不太可能需要使用它们。



**无名交换器**

在前面的章节中，我们对交换器一无所知，但仍然能够将消息发送到队列。这是可能的，因为我们使用的是默认交换器，它由空字符串（""）标识。

回想一下我们之前是如何发布消息的：

```java
channel.basicPublish("", "hello", null, message.getBytes());
```

第一个参数是交换器的名称。空字符串标识默认的或没有名称的交换器：如果消息存在，则将使用路由关键字（队列名称）指定的名称将消息路由到队列。



现在，我们可以发布消息到有名称的交换器：

```java
channel.basicPublish( "logs", "", null, message.getBytes());
```



## 临时队列

